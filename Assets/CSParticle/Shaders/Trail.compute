#pragma kernel Initialize
#pragma kernel Update

#include "ParticleDataType.cginc"

#define BLOCK_SIZE 512

StructuredBuffer<WorldData> world_data;
StructuredBuffer<Particle> particles;
StructuredBuffer<TrailParams> params;
RWStructuredBuffer<TrailEntity> entities;
RWStructuredBuffer<TrailHistory> history;
RWStructuredBuffer<TrailVertex> vertices;


[numthreads(BLOCK_SIZE,1,1)]
void Initialize(uint3 dtid : SV_DispatchThreadID)
{
    uint tid = dtid.x;

    uint max_history = params[0].max_history;
    {
        for(uint i=0; i<max_history; ++i) {
            history[tid*max_history + i].position = 0.0;
        }
    }
    {
        for(uint i=0; i<max_history*2; ++i) {
            vertices[tid*max_history*2 + i].position = 0.0;
            vertices[tid*max_history*2 + i].texcoord = 0.0;
        }
    }
}

[numthreads(BLOCK_SIZE,1,1)]
void Update(uint3 dtid : SV_DispatchThreadID)
{
    uint tid = dtid.x;
    if(particles[tid].lifetime <= 0.0) return;
    uint pid = particles[tid].id % params[0].max_entities;
    float3 ppos = particles[tid].position;
    float lifetime = particles[tid].lifetime;
    float scale = min(lifetime/0.1, 1.0);

    uint max_history = params[0].max_history;
    if(particles[tid].id != entities[pid].id) {
        for(uint i=0; i<max_history; ++i) {
            history[pid*max_history + i].position = ppos;
        }
        entities[pid].id = particles[tid].id;
    }

    int f = entities[pid].frame % max_history;
    history[pid*max_history + f].position = ppos;

    float3 camera = params[0].camera_position;
    float width = params[0].width;

    for(uint i=0; i<max_history; ++i) {
        uint inext = i==max_history-1 ? i : i+1;
        uint iprev = i==0 ? 0 : i-1;
        float3 pos = history[pid*max_history + (f+i)%max_history].position;
        float3 pos_next = history[pid*max_history + (f+inext)%max_history].position;
        float3 pos_prev = history[pid*max_history + (f+iprev)%max_history].position;

        float3 tangent = normalize(pos_next - pos_prev);
        float3 aim_camera= normalize(camera-pos);
        float3 distance = cross(tangent, aim_camera) * (width*0.5f*scale);

        float3 right= pos + distance;
        float3 left = pos - distance;

        vertices[pid*max_history*2 + i*2 + 0].position = right;
        vertices[pid*max_history*2 + i*2 + 1].position = left;
    }
    entities[pid].frame++;
}
