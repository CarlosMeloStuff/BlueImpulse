#pragma kernel ProcessInteraction_Impulse
#pragma kernel ProcessInteraction_SPH
#pragma kernel ProcessGBufferCollision
#pragma kernel ProcessColliders
#pragma kernel Integrate


struct Particle
{
	float3 position;
	float3 velocity;
	float speed;
	float lifetime;
	int hash;
	int hit_objid;
};

struct Sphere
{
	float3 center;
	float radius;
};

struct Capsule
{
	float3 pos1;
	float3 pos2;
	float radius;
};

struct Plane
{
	float3 normal;
	float distance;
};

struct Box
{
	float3 center;
	Plane planes[6];
};

struct AABB
{
	float3 center;
	float3 extent;
};

struct ColliderInfo
{
	int owner_objid;
	AABB aabb;
};


struct SphereCollider
{
	ColliderInfo info;
	Sphere shape;
};

struct CapsuleCollider
{
	ColliderInfo info;
	Capsule shape;
};

struct BoxCollider
{
	ColliderInfo info;
	Box shape;
};


struct WorldData
{
	float timestep;
	float particle_size;
	float particle_lifetime;
	float wall_stiffness;
	float decelerate;
	float gravity;
	int num_max_particles;
	int num_particles;
	int num_sphere_colliders;
	int num_capsule_colliders;
	int num_box_colliders;
	float3 world_center;
	float3 world_extent;
	float2 rt_size;
	float4x4 view_proj;
};

RWStructuredBuffer<WorldData>		world_data;
RWStructuredBuffer<Particle>		particles;
StructuredBuffer<SphereCollider>	sphere_colliders;
StructuredBuffer<CapsuleCollider>	capsule_colliders;
StructuredBuffer<BoxCollider>		box_colliders;
Texture2D							gbuffer_position;
Texture2D							gbuffer_normal;

SamplerState samplergbuffer_position
{
	Filter   = MIN_MAG_MIP_POINT;
	AddressU = Clamp;
	AddressV = Clamp;
};
SamplerState samplergbuffer_normal
{
	Filter   = MIN_MAG_MIP_POINT;
	AddressU = Clamp;
	AddressV = Clamp;
};

// thanks: http://gamedev.stackexchange.com/questions/32681/random-number-hlsl
float rand_1_05(in float2 uv)
{
	float2 noise = (frac(sin(dot(uv ,float2(12.9898,78.233)*2.0)) * 43758.5453));
	return abs(noise.x + noise.y) - 1.0;
}

bool IsOverlaped(float3 pos, AABB aabb)
{
	float3 wext = world_data[0].world_extent + world_data[0].particle_size;
	float3 rpos = pos-aabb.center;
	if(abs(rpos).x>wext.x || abs(rpos).y>wext.y || abs(rpos).z>wext.z)
	{
		return false;
	}
	return true;
}


[numthreads(1024,1,1)]
void ProcessInteraction_Impulse(uint3 dtid : SV_DispatchThreadID)
{
	// todo
}

[numthreads(1024,1,1)]
void ProcessInteraction_SPH(uint3 dtid : SV_DispatchThreadID)
{
	// todo
}

[numthreads(1024,1,1)]
void ProcessGBufferCollision(uint3 dtid : SV_DispatchThreadID)
{
	uint tid = dtid.x;
	if(particles[tid].lifetime==0.0) { return; }
	WorldData wd = world_data[0];

	float3 ppos = particles[tid].position;
	float3 pvel = particles[tid].velocity;

	float4 tpos4 = mul(wd.view_proj, float4(ppos, 1.0));
	float2 tpos = (tpos4.xy/tpos4.w + 1.0) * 0.5;
	tpos = tpos*wd.rt_size;

	float4 fpos4 = gbuffer_position[tpos];
	if(fpos4.w!=0.0) {
		float3 fnormal = gbuffer_normal[tpos].xyz;
		float r = 0.2;
		//float penetration = min(fpos4.w-tpos4.z-wd.particle_size, 0.0);
		float penetration = min(length(fpos4.xyz-ppos.xyz)-wd.particle_size-r, 0.0);
		{
			pvel += fnormal * (-penetration * wd.wall_stiffness * wd.timestep);
			particles[tid].velocity = pvel;
		}
	}
}



[numthreads(1024,1,1)]
void ProcessColliders(uint3 dtid : SV_DispatchThreadID)
{
	uint tid = dtid.x;
	if(particles[tid].lifetime==0.0) { return; }
	WorldData wd = world_data[0];

	float3 ppos = particles[tid].position;
	float3 pvel = particles[tid].velocity;
	int hit = -1;
	int i;

	// process sphere colliders
	for(i=0; i<wd.num_sphere_colliders; ++i) {
		SphereCollider col = sphere_colliders[i];
		if(!IsOverlaped(ppos, col.info.aabb)) { continue; }

		float radius_sum = col.shape.radius + wd.particle_size;
		float3 diff = ppos - col.shape.center;
		float penetration = min(length(diff)-radius_sum, 0.0f);
		float3 dir = normalize(diff);
		pvel += dir * -penetration * wd.wall_stiffness * wd.timestep;
		if(penetration<0.0) {
			hit = col.info.owner_objid;
		}
	}

	// process capsule colliders
	for(i=0; i<wd.num_capsule_colliders; ++i) {
		CapsuleCollider col = capsule_colliders[i];
		if(!IsOverlaped(ppos, col.info.aabb)) { continue; }

		float radius_sum = col.shape.radius + wd.particle_size;
		float3 pos1 = col.shape.pos1;
		float3 pos2 = col.shape.pos2;
		float3 d = pos2-pos1;
		float t = dot(ppos-pos1, pos2-pos1) / dot(d,d);
		float3 diff;
		if(t<=0.0f) {
			diff = ppos-pos1;
		}
		else if(t>=1.0f) {
			diff = ppos-pos2;
		}
		else {
			float3 nearest = pos1 + (pos2-pos1)*t;
			diff = ppos-nearest;
		}
		float len = length(diff);
		float penetration = min(len-col.shape.radius, 0.0f);
		float3 dir = diff/len;
		pvel += dir * -penetration * wd.wall_stiffness * wd.timestep;
		if(penetration<0.0) {
			hit = col.info.owner_objid;
		}
	}

	// process box colliders
	for(i=0; i<wd.num_box_colliders; ++i) {
		BoxCollider col = box_colliders[i];
		if(!IsOverlaped(ppos, col.info.aabb)) { continue; }

		int inside = 0;
		float closest_distance = -999.0f;
		float3 closest_normal;
		float3 rpos = ppos - col.shape.center;
		for(int p=0; p<6; ++p) {
			float3 plane_normal = col.shape.planes[p].normal;
			float plane_distance = col.shape.planes[p].distance;
			float distance = dot(rpos, plane_normal) + plane_distance - wd.particle_size;
			if(distance < 0.0f) {
				inside++;
				if(distance > closest_distance) {
					closest_distance = distance;
					closest_normal = plane_normal;
				}
			}
		}
		if(inside==6) {
			pvel += closest_normal * -closest_distance * wd.wall_stiffness * wd.timestep;
			hit = col.info.owner_objid;
		}
	}

	particles[tid].velocity = pvel;
	particles[tid].hit_objid = hit;
}


[numthreads(1024,1,1)]
void Integrate(uint3 dtid : SV_DispatchThreadID)
{
	uint tid = dtid.x;
	if(particles[tid].lifetime==0.0) { return; }
	WorldData wd = world_data[0];

	float3 ppos = particles[tid].position;
	float3 pvel = particles[tid].velocity;

	pvel.y -= wd.gravity * wd.timestep;
	pvel *= wd.decelerate;
	ppos += pvel * wd.timestep;

	{
		float3 relpos = ppos - wd.world_center;
		if(	abs(relpos).x>wd.world_extent.x ||
			abs(relpos).y>wd.world_extent.y ||
			abs(relpos).z>wd.world_extent.z)
		{
			particles[tid].lifetime = 0.0;
		}
	}

	particles[tid].position = ppos;
	particles[tid].velocity = pvel;
	particles[tid].speed = length(pvel);
	particles[tid].lifetime = max(particles[tid].lifetime-wd.timestep, 0.0);
}
