#pragma kernel Initialize
#pragma kernel Update

#define BLOCK_SIZE 1024

struct Particle
{
    float3 position;
    float id;
    float3 velocity;
    float speed;
    float params[4];
};

struct TrailParams
{
    float delta_time;
    float width;
    uint max_entities;
    uint max_history;
    float3 camera_position;
};

struct TrailEntity
{
    float id;
    float time;
    uint frame;
};

struct TrailHistory
{
    float3 position;
};

struct TrailVetices
{
    float3 position;
    float2 texcoord;
};

StructuredBuffer<Particle> particles;
StructuredBuffer<TrailParams> params;
RWStructuredBuffer<TrailEntity> entities;
RWStructuredBuffer<TrailHistory> history;
RWStructuredBuffer<TrailVetices> vertices;


[numthreads(BLOCK_SIZE,1,1)]
void Initialize(uint3 dtid : SV_DispatchThreadID)
{
    uint tid = dtid.x;

    uint max_history = params[0].max_history;
    {
        for(uint i=0; i<max_history; ++i) {
            history[tid*max_history + i].position = 0.0;
        }
    }
    {
        for(uint i=0; i<max_history*2; ++i) {
            vertices[tid*max_history*2 + i].position = 0.0;
            vertices[tid*max_history*2 + i].texcoord = 0.0;
        }
    }
}

[numthreads(BLOCK_SIZE,1,1)]
void Update(uint3 dtid : SV_DispatchThreadID)
{
    uint tid = dtid.x;

    uint max_history = params[0].max_history;
    if(particles[tid].id != entities[tid].id) {
        for(uint i=0; i<max_history; ++i) {
            history[tid*max_history + i].position = particles[tid].position;
        }
    }

    int f = entities[tid].frame % max_history;
    history[tid*max_history + f].position = particles[tid].position;

    float3 camera = params[0].camera_position;
    float width = params[0].width;

    for(uint i=0; i<max_history; ++i) {
        uint inext = i==max_history-1 ? i : i+1;
        uint iprev = i==0 ? 0 : i-1;
        float3 pos = history[tid*max_history + (f+i)%max_history].position;
        float3 pos_next = history[tid*max_history + (f+inext)%max_history].position;
        float3 pos_prev = history[tid*max_history + (f+iprev)%max_history].position;

        float3 tangent = normalize(pos_next - pos_prev);
        float3 aim_camera= normalize(camera-pos);
        float3 distance = cross(tangent, aim_camera) * (width*0.5f);

        float3 right= pos + distance;
        float3 left = pos - distance;

        vertices[tid*max_history*2 + i*2 + 0].position = right;
        vertices[tid*max_history*2 + i*2 + 1].position = left;
    }
    entities[tid].frame++;
}
